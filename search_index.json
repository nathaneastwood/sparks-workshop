[
["index.html", "sparkts Workshop Chapter 1 Introduction", " sparkts Workshop Nathan Eastwood 2018-03-29 Chapter 1 Introduction This half-day workshop is intended to be a brief look into the core components of R package building and using sparklyr. It is very heavily influenced by the excellent R Packages Book by Hadley Wickham. In this workshop you will learn how to write reproducible R code in the form of functions and how to test and document them. "],
["functions-r.html", "Chapter 2 Functions (R/) 2.1 Returning 2.2 Invisibly Returning 2.3 The Assignment Operator 2.4 The Pipe Operator 2.5 Argument Names 2.6 Getting Help 2.7 Installing R Packages 2.8 Loading R Packages", " Chapter 2 Functions (R/) Everything in R is an object. Everything we do to an object is a function. To write functions, we use the function() key word. Figure 1: How to write a quick function Functions follow the following format quick_maths &lt;- function(add1, add2, sub1) { cat( add1, &quot; plus &quot;, add2, &quot; is &quot;, add1 + add2, &quot; minus &quot;, sub1, &quot;, that&#39;s &quot;, add1 + add2 - sub1, &quot;\\nQuick maths!&quot;, sep = &quot;&quot; ) BRRR::skrrrahh(&quot;bigshaq&quot;) invisible(add1 + add2 - sub1) } quick_maths(2, 2, 1) # 2 plus 2 is 4 minus 1, that&#39;s 3 # Quick maths! 2.1 Returning Unlike python, in R you do not need an explicit return() at the end of a function. The only time you need this is for early returns, for example in an if () statement. The last statement of a function is returned be default in R. 2.2 Invisibly Returning Notice that the function above returns a value invisibly. This is useful for when you want the function to return something to be used later, but don’t want to print it to the console. x &lt;- quick_maths(2, 2, 1) # 2 plus 2 is 4 minus 1, that&#39;s 3 # Quick maths! x + 5 # [1] 8 2.3 The Assignment Operator The assignment operator in R is &lt;- but = works in the same way. It is best practice to use &lt;-. 2.4 The Pipe Operator The pipe operator (%&gt;%) has become a common tool within the R world. Introduced in the magrittr package, we read this symbol as “then”. It it used to “pipe” the left hand side into a function on the right hand side. It is used heavily within the “tidyverse”. library(dplyr) mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) 2.5 Argument Names We don’t need to explicitly state the argument names. In fact we can reorder the names or use shortened names (this is not good practice, however). quick_maths(add2 = 2, sub1 = 1, add1 = 2) # 2 plus 2 is 4 minus 1, that&#39;s 3 # Quick maths! quick_maths(su = 1, 2, 2) # 2 plus 2 is 4 minus 1, that&#39;s 3 # Quick maths! 2.6 Getting Help You can get help in R using either the ? function or the help() function. ?print You can search for things within R using ?? or help.search(). ??print 2.7 Installing R Packages We install packages with the install.packages() function. install.packages(&quot;sparklyr&quot;) To install a package from GitHub you can use the remotes package, first to install itself, and then to install a package. # Install remotes source(&quot;https://raw.githubusercontent.com/r-lib/remotes/master/install-github.R&quot;)$value(&quot;r-lib/remotes&quot;) # Use remotes to install the development version of sparklyr remotes::install_github(&quot;rstudio/sparklyr&quot;) 2.8 Loading R Packages We can load R packages using one of two functions: library() or require(). You should use library(), however. One bad consequence of require() is that if you require('foo') in the beginning of an R script, and use a function bar() in the foo package on line 175, R will throw an error object &quot;bar&quot; not found if foo was not installed. library(sparklyr) "],
["sparklyr.html", "Chapter 3 sparklyr 3.1 Installing a Local Version of Spark 3.2 Connecting to Spark 3.3 Reading Data 3.4 Calling Scala Methods 3.5 The Jar (inst/java/)", " Chapter 3 sparklyr 3.1 Installing a Local Version of Spark We connect to Spark and call Scala methods using the sparklyr package. To install a local version of Spark we can run. spark_install() To check the installation, run: spark_install_find() # $sparkDir # [1] &quot;/Users/neastwood/spark&quot; # # $packageLocalPath # [1] &quot;/Users/neastwood/spark/spark-2.2.0-bin-hadoop2.7.tgz&quot; # # $packageRemotePath # [1] &quot;https://d3kbcqa49mib13.cloudfront.net/spark-2.2.0-bin-hadoop2.7.tgz&quot; # # $sparkVersionDir # [1] &quot;/Users/neastwood/spark/spark-2.2.0-bin-hadoop2.7&quot; # # $sparkConfDir # [1] &quot;/Users/neastwood/spark/spark-2.2.0-bin-hadoop2.7/conf&quot; # # $sparkVersion # [1] &quot;2.2.0&quot; # # $hadoopVersion # [1] &quot;2.7&quot; # # $installed # [1] TRUE 3.2 Connecting to Spark The sparklyr package has a function called spark_connect() which we can configure to connect to a local instance of Spark or a server instance. Here we show some code for connecting locally. config &lt;- spark_config() config$sparklyr.gateway.address &lt;- &quot;127.0.0.1&quot; sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.2.0&quot;, config = config) # Re-using existing Spark connection to local 3.2.1 Data Types sparklyr has a function named sdf_schema() for exploring the columns of a tibble1 on the R side. The return value is a list, and each element is a list with two elements, containing the name and data type of each column. data &lt;- spark_read_json(sc, name = &quot;data&quot;, &quot;../../data_raw/Melt.json&quot;) %&gt;% spark_dataframe() sdf_schema(data) # $date # $date$name # [1] &quot;date&quot; # # $date$type # [1] &quot;StringType&quot; # # # $four # $four$name # [1] &quot;four&quot; # # $four$type # [1] &quot;LongType&quot; # # # $identifier # $identifier$name # [1] &quot;identifier&quot; # # $identifier$type # [1] &quot;StringType&quot; # # # $one # $one$name # [1] &quot;one&quot; # # $one$type # [1] &quot;LongType&quot; # # # $three # $three$name # [1] &quot;three&quot; # # $three$type # [1] &quot;LongType&quot; # # # $two # $two$name # [1] &quot;two&quot; # # $two$type # [1] &quot;LongType&quot; Here is a comparison of how R data types map to Spark data types. Other data types are not currently supported by sparklyr. R type Spark type logical BooleanType numeric DoubleType integer IntegerType character StringType list ArrayType sparklyr doesn’t currently have the ability to pass over more complex data types such as a List[String]. 3.2.2 Using other data types When passing an R list over to Scala, we get a Scala ArrayType and there is no current way to send a Scala List from R using sparklyr. However, some of our Scala functions require List inputs. Potential solutions to this issue are: Use Seq instead of List as the input type since Array has also the Seq trait in Scala, so everything works out-of-the-box. Use overloading, which allows us to define methods of same name but having different parameters or data types, though this has issues. For an example of how this works, see this link. Define a new Scala method for the same class that is called from R, which effectively invokes the toList function on the ArrayType and then calls the existing Scala method. We can create Java ArrayLists in the Spark environment using the following code: # map some R vector `x` to a java ArrayList al &lt;- invoke_new(sc, &quot;java.util.ArrayList&quot;) lapply(x, FUN = function(y){invoke(al, &quot;add&quot;, y)}) Note we don’t need to reassign the results of the lapply because it is adding values to the Scala List in the JVM. We can then convert this code to a Scala List using: invoke_static(sc, &quot;scala.collection.JavaConversions&quot;, &quot;asScalaBuffer&quot;, al) %&gt;% invoke(&quot;toSeq&quot;) %&gt;% invoke(&quot;toList&quot;) 3.3 Reading Data You can copy R data frames into Spark using the dplyr::copy_to function. (More typically, though, you’ll read data within the Spark cluster using the spark_read family of functions.) library(dplyr) iris_tbl &lt;- copy_to(sc, iris) iris_tbl 3.4 Calling Scala Methods There are three main functions for calling methods within Spark. invoke_new() # create new scala objects invoke_static() # call static methods from scala invoke() # call methods from scala object 3.5 The Jar (inst/java/) If you plan on having the Jar file within your R package, such that it is self contained, within the inst folder, you will need a java folder; this is where the Jar lives. We register this Jar using the dependencies.R file which is shown below. spark_dependencies &lt;- function(spark_version, scala_version, ...) { sparklyr::spark_dependency( jars = c( system.file( &quot;java/sparkts-0.4.0-SNAPSHOT-jar-with-dependencies.jar&quot;, package = &quot;sparkts&quot; ) ) ) } #&#39; @import sparklyr .onLoad &lt;- function(libname, pkgname) { sparklyr::register_extension(pkgname) } The .onLoad function is ran whenever sparkts is loaded. Registering an extension package will result in the package being automatically scanned for spark dependencies when a connection to Spark is created. Packages should typically register their extensions in their .onLoad hook – this ensures that their extensions are registered when their namespaces are loaded. Here we define the Jar by providing its path within the sparklyr::spark_dependency function. A tibble is a data.frame that provides stricter checking and better formatting than the traditional data.frame.↩ "],
["object-documentation-man.html", "Chapter 4 Object Documentation (man/) 4.1 Using roxygen2 to Document the Package", " Chapter 4 Object Documentation (man/) Documentation in R is saved as .Rd files. These live separately to our R functions which live in .R files. However we can generate our .Rd files using an R package called roxygen2 which parses the .R files. We include a roxygen header above the function definition. Each line of the roxygen header starts with the symbols #'. This is known as a roxygen comment. Following this we use special tags to indicate a particular component of the help file. However the first three elements have special meaning. The first three paragraphs of the header are treated as: The title of the help page (short, one sentence) The description for the help page (brief description of the function) The details section which can provide much more information about the function, what it implements etc. Following these lines we must use the tags to distinguish elements. These tags all start with an @ symbol. Some tags and their uses are: Tag Purpose @param Identify each of the function arguments and the corresponding help text @return Detail the output of the function @author Who wrote this function? @seealso Other functions that the user should also look at the help documentation for @examples Code examples of running the function @import/@importFrom Indicate a package or function within a package to be imported @export Indicate that this function should be exported (i.e. made visible to the end user) The following is an example of how this might look for an example function. #&#39; Sample from a dataset #&#39; #&#39; This function has been designed to sample from the rows of a two #&#39; dimensional data set returning all columns of the sampled rows. #&#39; #&#39; @param data The matrix or data.frame from which rows are to be sampled. #&#39; @param size The number of samples to take. #&#39; @param replace Should values be replaced? By default takes the value TRUE. #&#39; @param ... Any other parameters to be passed to the sample function. #&#39; #&#39; @return Returns a dataset of the same type as the input data with \\code{size} #&#39; rows. #&#39; #&#39; @author Nathan Eastwood &lt;neastwood@@mango-solutions.com&gt; #&#39; #&#39; @examples #&#39; sampleFromData(airquality, 100) #&#39; #&#39; @export sampleFromData &lt;- function(data, size, replace = TRUE, ...) { ... } To generate the .Rd files, we run the devtools::document() function (Ctrl/Cmd + Shift + D). 4.1 Using roxygen2 to Document the Package We can also generate the package documentation using roxygen2. For package documentation we need to include the tags @docType and @name. The header itself needs to be followed by NULL as all headers need to be followed by some form of R code. Whilst this header can go in any file, good practice is to create a separate R script which takes the package name that contains this header. In the sparkts package therefore, we have an R script named sparkts.R in the R directory containing the following: #&#39; A package for calling Scala methods from the spark-ts package &quot;_PACKAGE&quot; We could of course expand this by adding a description etc. "],
["testing-your-code.html", "Chapter 5 Testing Your Code 5.1 testthat 5.2 Behavior-driven development (BDD)", " Chapter 5 Testing Your Code You can use devtools::load_all() to simulate building and loading your package. This is useful for when you have written some new code or a new feature and you want to interactively run it. 5.1 testthat There are a number of ways of writing unit tests in R but the simplest is to use the package testthat. 5.1.1 Setting up the Test Framework We can set up a test framework in a package using the function use_testthat. use_testthat() This will create a test directory that contains: A script testthat.R that contains all the code required to run the package tests A directory testthat/ where we will save all of our test scripts The use_testthat function will also update the DESCRIPTION file accordingly to include testthat as a suggested package. 5.1.2 Writing Tests With the package testthat we create individual tests using functions named with the pattern expect_*. Some of the most common expect statements are given in the following table: Expectation Description expect_identical Checks for exact quality expect_equal Checks for equality with numerical tolerance expect_equivalent More relaxed version of equals expect_is Checks than an object inherits a specified class expect_matches Compares a character vector to a regular expression expect_true Checks that the logical TRUE is returned expect_false Checks that the logical FALSE is returned expect_error Checks that an expression throws an error expect_warning Checks that an expression gives a warning expect_message Checks that an expression issues a message We typically want to group tests which belong to a single function together. We do this in the test_that function. context(&quot;A and B have the same column names and same second column&quot;) test_that(&quot;Test that A is the same as B&quot;, { A &lt;- data.frame(x = rnorm(10), y = 1:10) B &lt;- data.frame(x = rnorm(10), y = 1:10) expect_equal(colnames(A), colnames(B)) expect_identical(A$y, B$y) }) The context function here indicates that all of the test_that groups that follow can be collected together. To structure this as tests for our package we would save all of the above into a single file. 5.1.3 Running Tests To run the tests in a package, we use the test() function from the devtools package. devtools::test() 5.2 Behavior-driven development (BDD) To implement BDD in R, one should use the testthat::describe() function. Examples can be seen in ?testthat::describe. More robust testing is done using the testthat package, however. "],
["package-components.html", "Chapter 6 Package Components 6.1 Package metadata (DESCRIPTION) 6.2 Namespaces (NAMESPACE) 6.3 Vignettes (vignettes/) 6.4 Installed Files (inst/) 6.5 utils.R", " Chapter 6 Package Components As a minimum we need 4 components in an R package: DESCRIPTION file NAMESPACE file R/ directory man/ directory We discuss the DESCRIPTION and NAMESPACE files below and introduce vignettes and the inst folder. To create a package, we can use the devtools::create() function or use the RStudio GUI. File &gt; New Project &gt; New or Existing Directory &gt; R Package. These two options set up the package components described above. 6.1 Package metadata (DESCRIPTION) The DESCRIPTION file is an important file for telling users of your package information such as who wrote the package, who is maintaining the package, what the current version of the package is and what other packages are needed to run your package among other things. Package: sparkts Title: Call Methods from the spark-ts Package Version: 0.0.4 Authors@R: person(&quot;Nathan&quot;, &quot;Eastwood&quot;, email = &quot;nathan.eastwood@icloud.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)) Description: This package is used for calling Scala methods from the spark-ts package. Depends: R (&gt;= 3.4.2), sparklyr Imports: dplyr License: file LICENSE Encoding: UTF-8 LazyData: true RoxygenNote: 6.0.1 Suggests: knitr, lintr, rmarkdown, testthat VignetteBuilder: knitr Notice that we have included: Details about what role authors take (author, creator, contributor) Packages required for the package and their version requirements The license for the package Notice here that the sparkts file references a separate LICENCE file which in this case just includes the information for the Apache 2.0 licence. 6.2 Namespaces (NAMESPACE) As the name suggests, NAMESPACE provides a “space” for “names”. It provides a context for looking up the value of an object associated with a name. When loading different packages, sometimes they can have functions with the same names. So how does R know which function to use? Take for example, the summarize functions in the Hmisc and plyr packages. A namespace make your package self-contained in two ways: the imports and the exports. The imports define how a function in one package finds a function in another. The exports help you avoid conflicts with other packages by specifying which functions are available outside of your package (internal functions are available only within your package and can’t easily be used by another package). You can, however, explicitly refer to specific functions: Hmisc::summarize() and plyr::summarize(). All the :: function does is explicitly load a function from a given package. To better understand how R searches and finds stuff, read this excellent blog post! An important point to note is that if you are using roxygen2 you do not need to edit the NAMESPACE file because you define your imports (@import, @importFrom) next to your function and then @export that function (if you want it to be callable by the end user). roxygen2 then does the hard work filling in your NAMESPACE file when it parses these tags. 6.3 Vignettes (vignettes/) Vignettes are essentially user guides for your package. They offer more detail than the files in your man/ folder and usually provide in depth explanations and examples for your package. The package structure for a vignette and a template file that we can start from can be created using the devtools::use_vignette() function. This will also appropriately update the DESCRIPTION file for us. devtools::use_vignette(&quot;QuickStart&quot;) Vignettes can be written using Rmarkdown which is a variant of markdown that allows the user to include code “chunks”. A package called knitr will then parse these chunks and create a markdown file including your text with the already ran code output. This can then be converted to a number of other file types. Code chunks take the following form: ```{r fun_ex} quick_maths &lt;- function(add1, add2, sub1) { cat( add1, &quot; plus &quot;, add2, &quot; is &quot;, add1 + add2, &quot; minus &quot;, sub1, &quot;, that&#39;s &quot;, add1 + add2 - sub1, &quot;\\nQuick maths!&quot;, sep = &quot;&quot; ) BRRR::skrrrahh(&quot;bigshaq&quot;) invisible(add1 + add2 - sub1) } quick_maths(2, 2, 1) ``` Notice here that we define a code chunk with three backticks following by a set of curly braces, the language (r) and then a name for that code chunk2. Inside the curly brackets we can include a number of additional options to control if and how the code is run and output. Option Values Behaviour echo TRUE/FALSE Controls whether R code is returned to the report. eval TRUE/FALSE Controls whether a code chunk is run and evaluated. This can be useful for displaying code in a report that we do not actually want to run. collapse TRUE/FALSE Collapses the R code and output into a single block. include TRUE/FALSE Determines whether the chunk is include in the report. If FALSE the code is run but nothing is included in the report relating to this chunk. results &quot;markup&quot;, &quot;asis&quot;, &quot;hold&quot;, &quot;hide&quot; Controls how the outputs are displayed. &quot;markup&quot; will mark up the results, &quot;asis&quot; will return the results in raw R, &quot;hold&quot; will not output until after the whole chunk has been evaluated, &quot;hide&quot; will hide the R output. comment &quot;##&quot; The output will have the character string &quot;##&quot; at the start of each line. Setting to NA will disable this. prompt TRUE/FALSE Whether or not to display the &gt; prompt before lines of code. Note that there are many other options you can use. 6.4 Installed Files (inst/) The inst folder is designed to hold any raw data files you may have or other files the package uses such as the Jar and raw data files. 6.4.1 Raw Data (inst/data_raw/) The sparkts package can use the raw JSON files used within the tests by storing them in a data_raw folder within the inst folder. You can set up the raw data folder using: devtools::use_data_raw() 6.5 utils.R Oftentimes your package will have lots of little helper functions which you call within your main functions. These should live within R/utils.R. These are generally non-exported functions. Note that you don’t need to name a code chunk but it is good for debugging purposes as it helps to track down failing chunks.↩ "],
["building-checking-and-installing-the-package.html", "Chapter 7 Building, Checking and Installing the Package 7.1 Check 7.2 Building and Installing", " Chapter 7 Building, Checking and Installing the Package So you’ve written your functions, their documentation and tests and now you would like to be able to load your package to use every time you use R. For this we have some additional steps. 7.1 Check Before you release your package you will want to run an R CMD check (the command line tool). This is made easy (and better) by the devtools::check() function. This function is composed of over 50 individual checks. It checks things such as the package metadata, structure, DESCRIPTION, NAMESPACE, R code, data, documentation, demos, compiled code, tests and vignettes. The workflow for checking a package is simple, but tedious: Run devtools::check(), or press Ctrl/Cmd + Shift + E Fix the first problem Repeat until there are no more problems R CMD check returns three types of messages: ERRORs WARNINGs NOTEs You should strive to fix all WARNINGs and ERRORs. You should also strive to fix all NOTEs, however these aren’t as serious and may sometimes be there for a valid reason (for example including a large Jar file). 7.2 Building and Installing To build and install the package, there are three options: Use the devtools::build() function Use the “Install and Restart” RStudio GUI button under the “Build” tab; or press Ctrl/Cmd + Shift + B Use the R CMD build followed by R CMD INSTALL command line functions 7.2.1 Build a Binary To build the binary for your package, use devtools::build(binary = TRUE). This will give you a .tar.gz version of your package. "],
["other-useful-tidbits.html", "Chapter 8 Other Useful Tidbits", " Chapter 8 Other Useful Tidbits Some great places for blog posts exist: R-bloggers brings together tonnes of R blogs R can be quirky, this blog post explains some of those quirks. R Package Primer: Minimum tutorial for R package building. Writing an R package from scratch Some great free R books are available: Advanced R R for Data Science covers the dplyr package which works seamlessly with sparklyr. R Cookbook R Packages Other great R websites include: Metacran: see trending and featured packages, search and browse all CRAN/R packages. R Seek: dedicated R Google search engine "],
["linting.html", "Chapter 9 Linting 9.1 lintr 9.2 styler", " Chapter 9 Linting Generally I have stuck to the tidyverse coding standards. These standards were implemented with the Data Science Campus. You can automatically format your code using two packages. 9.1 lintr The sparkts package automatically runs lintr to check for style errors during the test phase of the package check or when running devtools::test(). You can install lintr with: remotes::install_github(&quot;jimhester/lintr&quot;) Then to run the linter run lintr::lint_package() 9.2 styler The goal of styler is to provide non-invasive pretty-printing of R source code while adhering to the tidyverse formatting rules. You can run styler on your entire package using styler::style_pkg() Or you can style an individual file using the RStudio Addin. how to use styler to styler a file "]
]
